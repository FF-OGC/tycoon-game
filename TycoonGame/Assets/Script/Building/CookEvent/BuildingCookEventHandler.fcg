import "StdLibrary.fcc" as StdLib
import "EditorGenLib.fcc" as EditorLib
import "Hud.fcc" as Hud
import "List.fcc" as List

import "../../Global/CSVReadingHandler.fcg" as CSVReadingHandler
import "../../Player/PlayerStaticInformation.fcg" as PlayerStaticInformation
import "Items.fcc" as Items
import "../../Player/PlayerEquipment/PlayerEquipmentHandler.fcg" as PlayerEquipmentHandler
import "../../Player/PlayerTriggerEventHandler.fcg" as PlayerTriggerEventHandler
import "Math.fcc" as Math

import "../../Item/ItemHandler.fcg" as ItemHandler
import "../BuildingHandler.fcg" as BuildingHandler




graph BuildingCookEventHandler {
    isCooking bool

    inputParent entity
    outputParent entity

    inputChildrenList List<entity>
    outputChildrenList List<entity> 

    inputScenePostionList List<Vector3>
    outputScenePostionList List<Vector3>

    inputSceneEntityList List<entity>
    outputSceneEntityList List<entity>

    inputItemIDList List<int>

    outputItemIDList List<int>
    outputItemSizeList List<float>
    outputItemMutationList List<string>

    cookingStallPosition Vector3
    currentCookingItemID int
    currentCookingSceneEntity entity

    stallRotation Vector3

    owner entity<Player>

    //Executed when entity is created
    event OnAwake() {
    }

    func init (){
        inputParent = thisEntity<BuildingChildren>.Input
        outputParent = thisEntity<BuildingChildren>.Output

        inputChildrenList = List<entity>{}
        inputChildrenList = GetChildren(inputParent)
        outputChildrenList  = List<entity>{}
        outputChildrenList = GetChildren(outputParent)

        inputScenePostionList = List.New(5,5)
        for i = 0, List.Length(inputChildrenList), 1 {
            var tempt = inputChildrenList[i]
            inputScenePostionList[i]  = tempt<Transform>.Position + Vector3{0, 1, 0}
        }
        
        outputScenePostionList = List.New(5,5)
        for i = 0, List.Length(outputChildrenList), 1 {
            var tempt = outputChildrenList[i]
            outputScenePostionList[i]  = tempt<Transform>.Position + Vector3{0,1, 0}
        }

        cookingStallPosition = thisEntity<BuildingHandler>.model<Transform>.Position + Vector3{0, 0.5, 0}
        
        inputSceneEntityList = List<entity>{}
        inputItemIDList = List<int>{}

        outputSceneEntityList = List<entity>{}
        outputItemIDList = List<int>{}
        outputItemSizeList = List<float>{}
        outputItemMutationList = List<string>{}
        
        stallRotation = Vector3{0, 90, 0}
    }

    
    event COOK(itemID object) {
        if owner == nil {
            owner = PlayerStaticInformation.playerHost
        }

        DispatchEvent(SHOW_CUSTOMUI, owner, List<object>{"StartCooking"})
        LogInfo("event cook starting")
        addInputQueue(itemID as int)

        if isCooking == false{
            isCooking = true
            while isCooking{
                while List.Length(inputItemIDList) > 0 {
                    LogInfo("length + " +List.Length(inputItemIDList) )
                    var t = popInputQueue()
                    currentCookingSceneEntity<Transform>.Position = cookingStallPosition

                    var cookTimeCooldown = CSVReadingHandler.getItemCookingTimeByItemID(EResCSV.ItemCSV, currentCookingItemID)

                    WaitForMillisecond(cookTimeCooldown * 1000)
                    var cookItemOutputID = CSVReadingHandler.getOutputItemByItemID(EResCSV.ItemCSV,currentCookingItemID)
                    var randomSize = RandomFloat(0.5,10)

                    Destroy(currentCookingSceneEntity)

                    addOutputQueue(cookItemOutputID,randomSize,"", owner)
                }
                isCooking = false
            }
        }
    }


    func addOutputQueue(itemID int, itemSize float, itemMutation string , player entity<Player>){
        if checkOutputSlotAvailable(){
            Append(outputItemIDList, itemID) 
            Append(outputItemSizeList, itemSize) 
            Append(outputItemMutationList, itemMutation) 

            var CurrentIndex = List.Length(outputItemIDList) 
            var outputTableEntity = outputChildrenList[CurrentIndex-1]
            var outputPos = outputScenePostionList[CurrentIndex-1]
            Append(outputSceneEntityList, globalEntity<ItemHandler>.createItem(itemID, itemSize , itemMutation, outputPos, stallRotation))
        } else {
            LogInfo("Output is full")
            player<PlayerEquipmentHandler>.equipmentAddItem(itemID,itemSize,itemMutation)
        }
    }

    func popOutputQueue() {
        var outputItemID =  outputItemIDList[0]
        var outputItemSize = outputItemSizeList[0]
        var outputItemMutation = outputItemMutationList[0]

    
        if outputItemID != nil && outputItemID != -1 && outputItemID>0{
            LogInfo("owner<PlayerEquipmentHandler>.checkSlotAvailable() " + owner<PlayerEquipmentHandler>.checkSlotAvailable() )
            LogInfo("owner" + owner +"name " + owner<Entity>.Name)
            
            if owner<PlayerEquipmentHandler>.checkSlotAvailable() {
                owner<PlayerEquipmentHandler>.equipmentAddItem(outputItemID,outputItemSize,outputItemMutation)
    
                RemoveAt(outputItemIDList,0)
                RemoveAt(outputItemSizeList,0)
                RemoveAt(outputItemMutationList,0)
                Destroy(outputSceneEntityList[0])
                RemoveAt(outputSceneEntityList,0)
                matchSceneOutput()
            } else {
                LogInfo("full slot ")
            }

        }
    }


    func addInputQueue(itemID int){
        if checkInputSlotAvailable(){
            Append(inputItemIDList, itemID)
            var index = List.Length(inputItemIDList) as int
            var inputTableEntity = inputChildrenList[index-1]
            var outputPos = inputScenePostionList[index-1]
            Append(inputSceneEntityList, globalEntity<ItemHandler>.createItem(itemID, 1 , 0, outputPos, stallRotation))

        } else {
            LogInfo("full waiting")
        }
    }


    func popInputQueue () int{
        if List.Length(inputItemIDList) > 0 {
            var ItemIDListClone = List.Clone(inputItemIDList) as List<int>
            currentCookingItemID = ItemIDListClone[0] as int

            var SceneEntityListClone = List.Clone(inputSceneEntityList) as List<entity>
            currentCookingSceneEntity = SceneEntityListClone[0]
        
            RemoveAt(inputItemIDList,0)
            RemoveAt(inputSceneEntityList,0)
            matchSceneInput ()
            return currentCookingItemID
        } else {
        }
    }

    func matchSceneInput (){
        for i = 0, List.Length(inputSceneEntityList), 1 {
            var SEntity = inputSceneEntityList[i]
            SEntity<Transform>.Position = inputScenePostionList[i]    
        }
    }

    func matchSceneOutput (){
        for i = 0, List.Length(outputSceneEntityList), 1 {
            var SEntity = outputSceneEntityList[i]
            SEntity<Transform>.Position = outputScenePostionList[i]    
        }
    }

    func checkInputSlotAvailable() bool{
        if List.Length(inputItemIDList) < 5 {
            return true
        } else {
            return false
        }
    }

    func checkOutputSlotAvailable() bool {
        if List.Length(outputItemIDList) < 5 {
            return true
        } else {
            return false
        }
    }

    

}